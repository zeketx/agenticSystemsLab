import os
from typing import Optional, Dict, Any
from fastapi import FastAPI, Depends
from pydantic import BaseModel, Field
import psycopg2
from psycopg2.pool import ThreadedConnectionPool
import openai
import json

# --------------------------------------------------------------
# Models for Request and Response
# --------------------------------------------------------------
class ChatRequest(BaseModel):
    message: str = Field(..., min_length=1, description="User's input message to the chat")

class ChatResponse(BaseModel):
    reply: str = Field(..., description="Text response to the user")
    query: str = Field(..., description="SQL query generated by the LLM")

class ChatAPIResponse(BaseModel):
    reply: str
    query: str
    results: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

# --------------------------------------------------------------
# FastAPI App and Connection Pool
# --------------------------------------------------------------
app = FastAPI()

db_pool = None

@app.on_event("startup")
def startup_event():
    global db_pool
    db_pool = ThreadedConnectionPool(
        minconn=1,
        maxconn=10,
        user="postgres",
        password="postgres",
        host="localhost",
        port="5432",
        database="postgres"
    )

@app.on_event("shutdown")
def shutdown_event():
    global db_pool
    if db_pool:
        db_pool.closeall()

# --------------------------------------------------------------
# Dependency to Get Database Connection
# --------------------------------------------------------------
def get_db_connection():
    conn = db_pool.getconn()
    try:
        yield conn
    finally:
        db_pool.putconn(conn)

# --------------------------------------------------------------
# Database Schema Utilities
# --------------------------------------------------------------
def get_table_names(conn):
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_type='BASE TABLE';")
        tables = cursor.fetchall()
        cursor.close()
        return tables
    except Exception:
        return []

def get_column_names(conn, table_name):
    try:
        cursor = conn.cursor()
        cursor.execute(f"SELECT column_name, data_type FROM information_schema.columns WHERE table_name = '{table_name}' AND table_schema = 'public';")
        columns = cursor.fetchall()
        cursor.close()
        return columns
    except Exception:
        return []

def get_schema_summary(conn):
    tables = get_table_names(conn)
    if not tables:
        return "No tables found."
    schema = []
    for table in tables:
        table_name = table[0]
        columns = get_column_names(conn, table_name)
        column_list = [f"{col[0]} ({col[1]})" for col in columns]
        schema.append(f"Table: {table_name}\nColumns: {', '.join(column_list)}")
    return "\n".join(schema)

# --------------------------------------------------------------
# Generate SQL Query Using OpenAI
# --------------------------------------------------------------
def generate_sql_query(conn, user_message):
    client = openai.OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    if not os.getenv("OPENAI_API_KEY"):
        return ChatResponse(reply="OpenAI API key not set.", query="")
    
    schema_summary = get_schema_summary(conn)
    if "No tables found" in schema_summary:
        return ChatResponse(reply="No database schema available.", query="")

    response_schema = {
        "type": "object",
        "properties": {
            "reply": {"type": "string"},
            "query": {"type": "string"}
        },
        "required": ["reply", "query"],
        "additionalProperties": False
    }

    try:
        response = client.chat.completions.create(
            model="gpt-4o-2024-08-06",
            messages=[
                {"role": "system", "content": f"You are a SQL expert. Given the following database schema, generate a SQL query based on the user's request. Respond in JSON with 'reply' (a brief explanation) and 'query' (the SQL query).\nSchema:\n{schema_summary}"},
                {"role": "user", "content": user_message}
            ],
            response_format={
                "type": "json_schema",
                "json_schema": {
                    "name": "sql_response",
                    "schema": response_schema,
                    "strict": True
                }
            }
        )
        result = json.loads(response.choices[0].message.content)
        return ChatResponse(**result)
    except Exception as e:
        return ChatResponse(reply=f"Error generating query: {str(e)}", query="")

# --------------------------------------------------------------
# Execute SQL Query
# --------------------------------------------------------------
def execute_query(conn, query):
    if not query:
        return "No query provided."
    try:
        cursor = conn.cursor()
        cursor.execute(query)
        results = cursor.fetchall()
        column_names = [desc[0] for desc in cursor.description]
        cursor.close()
        return {"columns": column_names, "rows": results}
    except Exception as e:
        return f"Error executing query: {str(e)}"

# --------------------------------------------------------------
# API Endpoint for Chat
# --------------------------------------------------------------
@app.post("/chat", response_model=ChatAPIResponse)
def chat(request: ChatRequest, conn=Depends(get_db_connection)):
    chat_response = generate_sql_query(conn, request.message)
    if not chat_response.query:
        return ChatAPIResponse(
            reply=chat_response.reply,
            query="",
            error="No valid query generated."
        )
    
    if not chat_response.query.strip().upper().startswith("SELECT"):
        return ChatAPIResponse(
            reply="Only SELECT queries are allowed.",
            query=chat_response.query,
            error="Unsafe query detected."
        )
    
    result = execute_query(conn, chat_response.query)
    if isinstance(result, dict):
        return ChatAPIResponse(
            reply=chat_response.reply,
            query=chat_response.query,
            results=result
        )
    else:
        return ChatAPIResponse(
            reply=chat_response.reply,
            query=chat_response.query,
            error=result
        )